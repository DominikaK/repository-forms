# JSON Schema content forms

## Synopsis
An API endpoint that, for a content type identifier, responds with a content creation form
expressed using JSON schema, as specified in https://github.com/ezsystems/repository-forms/pull/113.

## Request/Response example

```bash
curl -X GET http://example.com/api/ezp/v2/content/create/article -H 'Accept: application/schema+json'
```

```json
{
    "title": "New Folder",
    "description": "Th most basic container",
    "type": "object",
    "required": [
        "name"
    ],
    "properties": {
        "name": {
            "type": "string",
            "title": "Name"
        },
        "short_name": {
            "type": "string",
            "title": "Short name"
        }
    }
}
```

### Piece by piece breakdown

- `title` and `description` are built from the Content Type identifier (article, folder...).
- `type` doesn't change
- `required` is built by iterating over the field definitions, and by adding those that are required
- `properties` is built from the fields. For each field definition:
  - The key (`name`, `short_name`) is the field definition identifier
  - `type` depends on the form widget type. What happens if there are several ?
  - `title` is the field definition's name

## Prototype 1

Pull-request: [ezsystems/repository-forms#114](https://github.com/ezsystems/repository-forms/pull/114).
Uses [limenius/liform-bundle](https://packagist.org/packages/limenius/liform-bundle), that provides
serialization of Symfony Forms into jsonschema.

http://site/content/create/nodraft/folder/eng-GB/2.json will respond with the jsonschema to create
a new folder:

```json
{
  "type": "object",
  "properties": {
    "fieldsData": {
      "type": "array",
      "items": [
        {
          "title": "title",
          "type": "object",
          "properties": {
            "value": {
              "type": "string",
              "title": "Title",
              "propertyOrder": 1
            }
          },
          "required": [
            "value"
          ]
        },
        {
          "title": "short_title",
          "type": "object",
          "properties": {
            "value": {
              "type": "string",
              "title": "Short title",
              "propertyOrder": 1
            }
          }
        },
        {
          "title": "author",
          "type": "object",
          "properties": []
        },
        {
          "title": "intro",
          "type": "object",
          "properties": []
        },
        {
          "title": "body",
          "type": "object",
          "properties": []
        },
        {
          "title": "enable_comments",
          "type": "object",
          "properties": {
            "value": {
              "type": "boolean",
              "title": "Enable comments",
              "propertyOrder": 1
            }
          }
        },
        {
          "title": "image",
          "type": "object",
          "properties": []
        }
      ],
      "propertyOrder": 1
    }
  },
  "required": [
    "fieldsData"
  ]
}
```

The output has been tested with https://mozilla-services.github.io/react-jsonschema-form/, and does output a
sensible form:

![Screenshot of mozilla react test service](https://cloud.githubusercontent.com/assets/235928/23326100/e1be97a8-fafa-11e6-87d6-fe548f716b66.png)

### Things to look into

#### The very complicated form
The form that is generated is very nested:
`properties > fieldsData > items > item[] > properties > value > {actual field value}`.

The resulting form, even if it has all the elements, has multiple depth level, requiring either to handle or simplify
that structure. This isn't an ideal developer experience. Options to simplify:

##### Option A: simplify the structure generated by the serializer
Before passing the structure returned by LiForm to the JSON serializer, walk through it to produce a simpler version.

> Pro: quick
> Con: dirty

##### Option B: generate a simpler form object
Reduce the nesting level in `ContentEditType` (new `FormType`). The challenge is that this nested structure is used to
"map" the underlying objects to Symfony Forms. Building the Form _and_ processing POSTed data is done by mapping
an object tree. Each property of the passed object is mapped to its own FormType.

The `Content` is not enough to build the form. It needs to be mapped with the `ContentType` it is an instance of to 
get the type of each File. This is what the `ContentEditFormMapper` does:
- it builds a `ContentUpdateData` object with the `Content` and the `ContentType`
- it iterates over the `ContentType`'s FieldDefinitions, and adds `FieldData` objects to the `ContentUpdateData`.
  A `FieldData` object is an aggregate of `Field`, `FieldDefinition` and th Field's `Value`.

An option would be to use an object that has Field objects, representing each edited Field, at the root level (mapped
to "properties" in the form). Each `Field` object _will_ have to be mapped to a `FormType`, so that the editing UI of
the FieldType can be rendered. This is where FieldMappers are used. 

> Pro: clean
> Con: complicated

###### Digging further
To fully use this form object, it needs to be very close from the edited object.
For a content type with:
- `title`, a TextLine Field
- `body`, a RichText Field
- `image`, an Image Field

`ContentFormType`:
- `title`: `TextLineFormType`
- `body`: `RichTextFormType`
- `image`: `ImageEditFormType`

The `TextLineType`, `RichTextType` and `ImageEditType` are FormTypes ! Do we want to require that any FieldType
comes with its own FormType ? At least it would be close to Symfony Forms _and_ our own Domain.

The `ContentFormType` will have a listener that reads the input object, and adds the FormTypes above
for each. What input should it expect ?

**A whole Content, when editing a stored draft**
Any pitfall ?

**A ContentCreateStruct, when creating a new content without a draft stored**
We have the `contentTypeIdentifier`, `language` and `parentLocationId` as controller arguments.
The Form will add the Fields for each Field in the provided object. For each, it needs its
FieldDefinition (fieldTypeIdentifier, identifier, name, required, validation...), the Fields
from the Value (`text` for `TextLine`, `latitude`, `longitude` and `address` for `Maplocation`, ...).

Do we have everything we need in a ContentCreateStruct ?
- From the ContentType, we can get the FieldDefinitions.
- From each FieldDefinition, we get the fieldTypeIdentifier, identifier, name, required, validation...
- We can load the FieldType using the FieldTypeRegistry.
- As for the Value, we can use:
  - Either the matching FieldValue from the ContentCreateStruct, if it was set
  - or the EmptyValue from The FieldType

A `ContentCreateStruct` stores Fields as a numerically indexed array of `API\Content\Fields`.
A Field has the fieldDefIdentifier, languageCode and value, as the FieldType's Value.

When writing a FieldType, we'd like to manipulate properties from our FieldValue directly.
Example:

```php
    public function buildForm(FormBuilderInterface $builder, array $options)
    {
        $builder
            ->add(
                'latitude',
                NumberType::class,
                ['label' => 'Latitude', 'scale' => 5, 'property_path' => 'latitude', 'required' => $options['required']])
            ->add(
                'longitude',
                NumberType::class,
                ['label' => 'Longitude', 'scale' => 5, 'property_path' => 'longitude', 'required' => $options['required']])
            ->add(
                'address',
                TextType::class,
                ['label' => 'Address', 'empty_data' => '', 'property_path' => 'address', 'required' => $options['required']]);
    }
```

It means that the Form data class must be the `Value`, not the `Field`. How is the `Field` built ?
Should we try to use more of the Forms options ? They're given by the controller, meaning that we don't
need to transport them. They can be obtained using the route (or the session. Yuk ?)
